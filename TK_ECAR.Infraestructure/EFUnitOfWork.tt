<#@ template language="C#" debug="true" hostspecific="true"#>
<#@ include file="EF.Utility.CS.ttinclude"#>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Diagnostics" #>

<#@ output extension=".cs"#>
<#

// This needs to be set to the .edmx files that you want to process.
string[] edmxFiles = FindEDMXFiles();


CodeGenerationTools code = new CodeGenerationTools(this);
MetadataLoader loader = new MetadataLoader(this);
MetadataTools ef = new MetadataTools(this);
  
#>
//------------------------------------------------------------------------------
// <auto-generated>
// Este código es autogenerado T4
// </auto-generated>
//------------------------------------------------------------------------------

<#

List<EntityContainer> contenedores = new List<EntityContainer>();
foreach (string file in edmxFiles)
{
	EdmItemCollection ItemCollection = loader.CreateEdmItemCollection(file);

	contenedores.AddRange(ItemCollection.GetItems<EntityContainer>());
}

//EdmItemCollection ItemCollection = loader.CreateEdmItemCollection(edmxFile);
//EntityContainer container = ItemCollection.GetItems<EntityContainer>().FirstOrDefault();
EntityFrameworkTemplateFileManager fileManager = EntityFrameworkTemplateFileManager.Create(this);
//EntityContainer container = contenedores.First();
//List<EntityType> entidades = new List<EntityType>();

foreach (EntityContainer container in contenedores)
{
	List<EntityType> entidades = new List<EntityType>();
	foreach (var set in container.BaseEntitySets)
	{
		if (set.ElementType.GetType() == typeof(EntityType)) 
		{
			entidades.Add((EntityType)set.ElementType);
		}
	}

//foreach (EntityType entity in ItemCollection.GetItems<EntityType>().OrderBy(e => e.Name))
foreach (EntityType entity in entidades)
{;

    if(!DoesFileExist("Repository" + entity.Name + ".cs"))
    {
        fileManager.StartNewFile("Repository" + entity.Name + ".cs");
        #>using TK_ECAR.Domain;
 
    
namespace <#= code.VsNamespaceSuggestion() #>
{   
    <#=Accessibility.ForType(entity)#> <#=code.SpaceAfter(code.AbstractOption(entity))#>partial class Repository<#=code.Escape(entity)#> : RepositoryBase<<#=code.Escape(entity)#>>, IRepository<#=code.Escape(entity)#>
    {
		public Repository<#=code.Escape(entity)#>(<#=code.Escape(container)#> context)
            : base(context)
        {

        }
    }
}<#
    }
    else
    {
        fileManager.StartNewFile("Repository" + entity.Name + ".cs");
        this.Write(OutputFile("Repository" + entity.Name + ".cs"));
    }
} //foreach Entidades
}//foreach contenedores


fileManager.StartNewFile("RepositoryBase.cs");
#>using System.Data.Entity;
using System.Linq.Expressions;
using System;
using System.Linq;
using TK_ECAR.Domain;
using TK_ECAR.Domain.Specifications;
using System.Collections.Generic;

namespace <#= code.VsNamespaceSuggestion() #>
{
    public partial class RepositoryBase<T> : IRepositoryBase<T> where T : class
	{
        private DbContext context;
        private DbSet<T> dbSet;

        public RepositoryBase(DbContext context)
        {
            this.context = context;
            this.dbSet = context.Set<T>();
        }

        public virtual T GetByID(object id)
        {
            return dbSet.Find(id);
        }

        public virtual void Insert(T entity)
        {
            dbSet.Add(entity);
        }

        public virtual void Delete(object id)
        {
            T entityToDelete = dbSet.Find(id);
            Delete(entityToDelete);
        }

        public virtual void RemoveRange(IEnumerable<T> entity)
        {
            dbSet.RemoveRange(entity);
        }


        public virtual void Delete(T entityToDelete)
        {
            if (context.Entry(entityToDelete).State == EntityState.Detached)
            {
                dbSet.Attach(entityToDelete);
            }
            dbSet.Remove(entityToDelete);
        }

        public virtual void Update(T entityToUpdate)
        {
            dbSet.Attach(entityToUpdate);
            context.Entry(entityToUpdate).State = EntityState.Modified;
        }


        public virtual IQueryable<T> FindAll(Expression<Func<T, bool>> filter = null)
        {
           
            var query = filter != null ? Fetch().Where(filter) : Fetch(); 

            return query;
        }

        public virtual IQueryable<T> FindAll(out int totalRows, Expression<Func<T, bool>> filter = null, int skip = 0, int take = 10)
        {
            IQueryable<T> query = FindAll(  filter );

            
            totalRows = query.Count();

            query = query.Skip(skip * take).Take(take);
  
            
            return query ;
        }


        public virtual T FindOne(Expression<Func<T, bool>> filter)
        {
           
            return Fetch().FirstOrDefault(filter);
        }

        public virtual IQueryable<T> Fetch()
        {
            IQueryable<T> query = dbSet;

            return query.AsQueryable();
        }

		public virtual IQueryable<T> Where(ISpecification<T> specfication)
        {
            IQueryable<T> query = dbSet;

            return query.Where(specfication.GetExpression()) ;
        }
		 
		public virtual IQueryable<T> Include(params Expression<Func<T, object>>[] includes)

        {
            IQueryable<T> query = dbSet;
            foreach (var include in includes)
            {
                query = query.Include(include);
            }

            return query;
        }

        public DbContext InternalContext
        {
            get { return this.context; }
        }
    }
}<#fileManager.StartNewFile("UnitOfWork.cs");
#>using System;
using TK_ECAR.Domain;

namespace <#= code.VsNamespaceSuggestion() #>
{
    public partial class UnitOfWork :  IUnitOfWork, IDisposable
    {

		<#
			string primero = "";
			bool primer = true;
			foreach (EntityContainer conta in contenedores)
			{
				string tipo = code.Escape(conta);
				if (primer)
				{
				primero = "context_" + code.Escape(conta);
				primer = false;
				}
				
				WriteContextRepositories(conta, tipo, code);
			}
		#>	

        public void Commit()
        {
            <#= primero #>.SaveChanges();
        }

        public bool LazyLoadingEnabled
        {
            get { return <#= primero #>.Configuration.LazyLoadingEnabled; }
            set { <#= primero #>.Configuration.LazyLoadingEnabled = value; }
        }

        public bool ProxyCreationEnabled
        {
            get { return <#= primero #>.Configuration.ProxyCreationEnabled; }
            set { <#= primero #>.Configuration.ProxyCreationEnabled = value; }
        }

        public string ConnectionString
        {
            get { return <#= primero #>.Database.Connection.ConnectionString; }
            set { <#= primero #>.Database.Connection.ConnectionString = value; }
        }

        private bool disposed = false;

        protected virtual void Dispose(bool disposing)
        {
            if (!this.disposed)
            {
                if (disposing)
                {
                    <#= primero #>.Dispose();
					
                }
            }
            this.disposed = true;
        }

        public void Dispose()
        {
            Dispose(true);
            GC.SuppressFinalize(this);
        }
    }
}
 
  
<#    fileManager.Process();
#>
 

<#+

bool DoesFileExist(string filename)
{            
    return File.Exists(Path.Combine(GetCurrentDirectory(),filename));    
}

string OutputFile(string filename)
{
    using(StreamReader sr = new StreamReader(Path.Combine(GetCurrentDirectory(),filename)))
    {
        string contents = sr.ReadToEnd();
        return contents;
    }
}

string GetCurrentDirectory()
{
    string executingDirectoryName = "";
    string stackTraceFileName = new StackTrace(true).GetFrame(0).GetFileName();
    if (String.IsNullOrEmpty(stackTraceFileName))
    {
        throw new ArgumentException("No value was specified for the 'directoryName' configuration parameter" +
            ", and we could not figure out the file name from the stack trace (most likely because of running " +
            "the template with debug='False' specified in the <\u0023@ template \u0023> directive.");
    }
    else
    {        
        executingDirectoryName = Path.GetDirectoryName(stackTraceFileName);
    }    
    return executingDirectoryName;
}

string FindEDMXFileName()
{
    string edmxFile = "";
	 
	string solutionsPath = Host.ResolveAssemblyReference("$(SolutionDir)");

   string path = solutionsPath + "TK_ECAR.Domain/";

	string[] entityFrameworkFiles = Directory.GetFiles(path, "Model.edmx");
    if(entityFrameworkFiles.Length > 0)
        edmxFile = entityFrameworkFiles[0];
    
    return edmxFile;
}

string[] FindEDMXFiles()
{
	string solutionsPath = Host.ResolveAssemblyReference("$(SolutionDir)");

    string path = solutionsPath + "TK_ECAR.Domain/";

	return Directory.GetFiles(path, "*.edmx");
}

void WriteContextRepositories(EntityContainer conta, string tipo, CodeGenerationTools code)
{
	string _nombre = "_context_" + conta.Name;
	string nombre = "context_" + conta.Name;
	#>
		<#=tipo#> <#=_nombre#> = null;
        private  <#=tipo#> <#=nombre#>
        {
            get
            {
                if (<#= _nombre#> == null)
                    <#= _nombre#> = new <#=tipo#>();

                return <#= _nombre#>;
            }
        }

		 #region Repositories
	<#+
		foreach (var set in conta.BaseEntitySets)
		{
			if (set.ElementType.GetType() != typeof(EntityType)) continue;

			EntityType entity = (EntityType)set.ElementType;

			#>

			private IRepository<#=code.Escape(entity)#> repository<#=code.Escape(entity)#>;
			  
			public IRepository<#=code.Escape(entity)#> Repository<#=code.Escape(entity)#>
			{
				get
				{

					if (repository<#=code.Escape(entity)#> == null)
					{
						repository<#=code.Escape(entity)#> = new Repository<#=code.Escape(entity)#>(<#=nombre#>);
					}
					return repository<#=code.Escape(entity)#>;
				}
			}

		<#+
		}#> 
		
		#endregion
	<#+
}

#>