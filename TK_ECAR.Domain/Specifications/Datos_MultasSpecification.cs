//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated from a template.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Linq;
using System.Linq.Expressions;


using System.Collections.Generic;
using TK_ECAR.Domain.DomainModel;

namespace TK_ECAR.Domain.Specifications
{
    
    [System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
    [System.CodeDom.Compiler.GeneratedCode("GeneratedCode","1.0")]
    
    [Serializable]
    public partial class Datos_MultasSpecification : ISpecification<Datos_Multas>
    {
    
        public string Matricula
        {
            get; 
            set;
        }
    		
    	public IEnumerable<string> MatriculaIN
    	{
    		get;
    		set;
    	}
    
    	public string MatriculaContains
    	{
    		get;
    		set;
    	}
    	
    	public string MatriculaStartsWith
    	{
    		get;
    		set;
    	}
    	
    	public string MatriculaEndsWith
    	{
    		get;
    		set;
    	}
    
    
        public Nullable<System.DateTime> Fecha
        {
            get; 
            set;
        }
    		
    	public IEnumerable<Nullable<System.DateTime>> FechaIN
    	{
    		get;
    		set;
    	}
    
    	public Nullable<System.DateTime> FechaFrom
    	{
    		get;
    		set;
    	}
    	
    	public Nullable<System.DateTime> FechaTo
    	{
    		get;
    		set;
    	}
    	 
        
    
    	public Nullable<System.DateTime> FechaFromOrNull
        {
            get;
            set;
        }
    
                    
        public Nullable<System.DateTime> FechaToOrNull
        {
            get;
            set;
        }
    		
    
        public Nullable<int> Conductor
        {
            get; 
            set;
        }
    		
    	public IEnumerable<Nullable<int>> ConductorIN
    	{
    		get;
    		set;
    	}
    
    	public Nullable<int> ConductorFrom
    	{
    		get;
    		set;
    	}
    	
    	public Nullable<int> ConductorTo
    	{
    		get;
    		set;
    	}
    	 
        
    
    
        public Nullable<double> Importe
        {
            get; 
            set;
        }
    		
    	public IEnumerable<Nullable<double>> ImporteIN
    	{
    		get;
    		set;
    	}
    
    	public Nullable<double> ImporteFrom
    	{
    		get;
    		set;
    	}
    	
    	public Nullable<double> ImporteTo
    	{
    		get;
    		set;
    	}
    	 
        
    
    
        public string Motivo
        {
            get; 
            set;
        }
    		
    	public IEnumerable<string> MotivoIN
    	{
    		get;
    		set;
    	}
    
    	public string MotivoContains
    	{
    		get;
    		set;
    	}
    	
    	public string MotivoStartsWith
    	{
    		get;
    		set;
    	}
    	
    	public string MotivoEndsWith
    	{
    		get;
    		set;
    	}
    
    
        public Nullable<bool> Contrario
        {
            get; 
            set;
        }
    		
    	public IEnumerable<Nullable<bool>> ContrarioIN
    	{
    		get;
    		set;
    	}
    
        public Nullable<bool> Cobertura
        {
            get; 
            set;
        }
    		
    	public IEnumerable<Nullable<bool>> CoberturaIN
    	{
    		get;
    		set;
    	}
    
        public Nullable<bool> EmitidaAlerta
        {
            get; 
            set;
        }
    		
    	public IEnumerable<Nullable<bool>> EmitidaAlertaIN
    	{
    		get;
    		set;
    	}
    
        public Nullable<System.DateTime> FAlta
        {
            get; 
            set;
        }
    		
    	public IEnumerable<Nullable<System.DateTime>> FAltaIN
    	{
    		get;
    		set;
    	}
    
    	public Nullable<System.DateTime> FAltaFrom
    	{
    		get;
    		set;
    	}
    	
    	public Nullable<System.DateTime> FAltaTo
    	{
    		get;
    		set;
    	}
    	 
        
    
    	public Nullable<System.DateTime> FAltaFromOrNull
        {
            get;
            set;
        }
    
                    
        public Nullable<System.DateTime> FAltaToOrNull
        {
            get;
            set;
        }
    		
    
    
    	/// <summary>
    	/// Default constructor (needed for serialization)
    	/// Initializes a new instance of the <see cref="Datos_MultasSpecification"/> class.
    	/// </summary>
    	public Datos_MultasSpecification()
    	{
    
    	}
    
    	/// <summary>
    	/// Initializes a new instance of the <see cref="Datos_MultasSpecification"/> class.
    	/// </summary>
    	/// <param name="initializeNavigationProperties">if set to <c>true</c> initialize navigation properties.</param>
    	public Datos_MultasSpecification(bool initializeNavigationProperties)
    	{
    		if(!initializeNavigationProperties)
    			return;
    
    	}
    
        #region ISpecification Members
    
    	public Expression<Func<Datos_Multas, bool>> GetExpression()
    	{
    		Expression<Func<Datos_Multas, bool>> expression = x => true;
    	
    		if(!string.IsNullOrWhiteSpace(Matricula))  
    			expression = expression.And(x => x.Matricula.Equals(Matricula));
    			
    		if(!string.IsNullOrWhiteSpace(MatriculaContains))  
    			expression = expression.And(x => x.Matricula.Contains(MatriculaContains));
    			
    		if(!string.IsNullOrWhiteSpace(MatriculaStartsWith))
    			expression = expression.And(x => x.Matricula.StartsWith(MatriculaStartsWith));
    
    		if(!string.IsNullOrWhiteSpace(MatriculaEndsWith))
    			expression = expression.And(x => x.Matricula.EndsWith(MatriculaEndsWith));
    
    		if(MatriculaIN != null && MatriculaIN.Count() > 0)
    			expression = expression.And(x => MatriculaIN.Contains(x.Matricula));
    
    		if(Fecha.HasValue)
    			expression = expression.And(x => x.Fecha == Fecha.Value);
    
    		if(FechaIN != null && FechaIN.Count() > 0)
    			expression = expression.And(x => FechaIN.Contains(x.Fecha));
    	
    		if(FechaFrom.HasValue)
    			expression = expression.And(x => x.Fecha >= FechaFrom.Value);
    			
    		if(FechaTo.HasValue)
    			expression = expression.And(x => x.Fecha <= FechaTo.Value);
    				
    
    		if(FechaFromOrNull.HasValue)
                expression = expression.And(x => x.Fecha >= FechaFromOrNull.Value || x.Fecha == null);
    
            if(FechaToOrNull.HasValue)
                expression = expression.And(x => x.Fecha <= FechaToOrNull.Value || x.Fecha == null);
    
    		if(Conductor.HasValue)
    			expression = expression.And(x => x.Conductor == Conductor.Value);
    
    		if(ConductorIN != null && ConductorIN.Count() > 0)
    			expression = expression.And(x => ConductorIN.Contains(x.Conductor));
    	
    		if(ConductorFrom.HasValue)
    			expression = expression.And(x => x.Conductor >= ConductorFrom.Value);
    			
    		if(ConductorTo.HasValue)
    			expression = expression.And(x => x.Conductor <= ConductorTo.Value);
    				
    
    
    		if(Importe.HasValue)
    			expression = expression.And(x => x.Importe == Importe.Value);
    
    		if(ImporteIN != null && ImporteIN.Count() > 0)
    			expression = expression.And(x => ImporteIN.Contains(x.Importe));
    	
    		if(ImporteFrom.HasValue)
    			expression = expression.And(x => x.Importe >= ImporteFrom.Value);
    			
    		if(ImporteTo.HasValue)
    			expression = expression.And(x => x.Importe <= ImporteTo.Value);
    				
    
    	
    		if(!string.IsNullOrWhiteSpace(Motivo))  
    			expression = expression.And(x => x.Motivo.Equals(Motivo));
    			
    		if(!string.IsNullOrWhiteSpace(MotivoContains))  
    			expression = expression.And(x => x.Motivo.Contains(MotivoContains));
    			
    		if(!string.IsNullOrWhiteSpace(MotivoStartsWith))
    			expression = expression.And(x => x.Motivo.StartsWith(MotivoStartsWith));
    
    		if(!string.IsNullOrWhiteSpace(MotivoEndsWith))
    			expression = expression.And(x => x.Motivo.EndsWith(MotivoEndsWith));
    
    		if(MotivoIN != null && MotivoIN.Count() > 0)
    			expression = expression.And(x => MotivoIN.Contains(x.Motivo));
    
    		if(Contrario.HasValue)
    			expression = expression.And(x => x.Contrario == Contrario.Value);
    
    		if(ContrarioIN != null && ContrarioIN.Count() > 0)
    			expression = expression.And(x => ContrarioIN.Contains(x.Contrario));
    
    		if(Cobertura.HasValue)
    			expression = expression.And(x => x.Cobertura == Cobertura.Value);
    
    		if(CoberturaIN != null && CoberturaIN.Count() > 0)
    			expression = expression.And(x => CoberturaIN.Contains(x.Cobertura));
    
    		if(EmitidaAlerta.HasValue)
    			expression = expression.And(x => x.EmitidaAlerta == EmitidaAlerta.Value);
    
    		if(EmitidaAlertaIN != null && EmitidaAlertaIN.Count() > 0)
    			expression = expression.And(x => EmitidaAlertaIN.Contains(x.EmitidaAlerta));
    
    		if(FAlta.HasValue)
    			expression = expression.And(x => x.FAlta == FAlta.Value);
    
    		if(FAltaIN != null && FAltaIN.Count() > 0)
    			expression = expression.And(x => FAltaIN.Contains(x.FAlta));
    	
    		if(FAltaFrom.HasValue)
    			expression = expression.And(x => x.FAlta >= FAltaFrom.Value);
    			
    		if(FAltaTo.HasValue)
    			expression = expression.And(x => x.FAlta <= FAltaTo.Value);
    				
    
    		if(FAltaFromOrNull.HasValue)
                expression = expression.And(x => x.FAlta >= FAltaFromOrNull.Value || x.FAlta == null);
    
            if(FAltaToOrNull.HasValue)
                expression = expression.And(x => x.FAlta <= FAltaToOrNull.Value || x.FAlta == null);
    		
    		//
    		// Navigation properties
    		//
    	
    		return expression;
    	}
    	
    	public bool IsSatisfiedBy(Datos_Multas entity)
    	{
    		// convert single entity to a IQueryable object, 
    		// in order to be able to use lambda expressions
    		IQueryable<Datos_Multas> entities = (new[] { entity }).AsQueryable();
    		
    		return entities.Any(this.GetExpression());
    	}
    
        public override string ToString()
        {
            return Evaluator.PartialEval(this.GetExpression()).ToString();
        }

        #endregion

    }
}
